#!/bin/bash
# Command parser invoked after lib loading
# syntax: autobuild command1 [args] [then command2 [args] [then ... ]] [ continue ] [ args left for other modules ]
# This roughly provides a looks-like-promise programmable commanding.
# TODO: magic command 'catch', default actions for commands.
_command='clean init --help stop '
_command_fun=''
_command_var=''
# new_command name VARS [-- tmpfuns]
# creates a new command and mark the var as to_unset.
new_command(){
	_command+="command_$1 "
	shift
	local cmdinfo
	_IFS="$IFS" IFS='--' cmdinfo=($*) IFS="$_IFS"
	_command_var+="${cmdinfo[0]} "
	_command_fun+="${cmdinfo[1]} "
}
command_clean(){ rm -rf "$SRCDIR"/ab{dist,scripts,spec}; }
command_stop(){
	[ "$1" ] || set -- 'command_stop'
	die "$@"
}
abplug command
while true; do
	case "$1" in
		then)	# marks the start of next command
			# if ((!catch))
			command_"${cmdbuf[@]}" || die "command return value exit."
			# || catch=1
			cmdbuf=();;
		catch)	# tells what to do if any previous command on the chain failed
			# if ((catch)) run defaultval die || catch=1;
			cmdbuf=();;
		continue)	# stops the processing
			shift
			break;;
		*)
			cmdbuf+=("$1");;
	esac
	shift || break
done
command_"${cmdbuf[@]}"
unset $_command $_command_fun $_command_var
